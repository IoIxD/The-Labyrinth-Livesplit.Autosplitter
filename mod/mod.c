#include <jni.h>
#include <memory.h>
#include <stdint.h>
#include <stdbool.h>

struct {
  // Memory hook so that we can identify where this struct is.
  uint8_t hook[283];
  // the actual information we want to store
  double x;
  double y;
  double z;
  bool shouldReset;
} GLOBAL_INFO;

static bool hasInited = false;

// "The FitnessGramâ„¢ Pacer Test is a multistage aerobic capacity test that
// progressively gets more difficult as it continues. The 20 meter pacer test
// will begin in 30 seconds. Line up at the start. The running speed starts
// slowly, but gets faster each minute after you hear this signal."
static uint8_t HOOK_VALUE[283] = {
    0x54, 0x68, 0x65, 0x20, 0x46, 0x69, 0x74, 0x6e, 0x65, 0x73, 0x73, 0x47,
    0x72, 0x61, 0x6d, 0x21, 0x22, 0x20, 0x50, 0x61, 0x63, 0x65, 0x72, 0x20,
    0x54, 0x65, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6d, 0x75,
    0x6c, 0x74, 0x69, 0x73, 0x74, 0x61, 0x67, 0x65, 0x20, 0x61, 0x65, 0x72,
    0x6f, 0x62, 0x69, 0x63, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74,
    0x79, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x6c,
    0x79, 0x20, 0x67, 0x65, 0x74, 0x73, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20,
    0x64, 0x69, 0x66, 0x66, 0x69, 0x63, 0x75, 0x6c, 0x74, 0x20, 0x61, 0x73,
    0x20, 0x69, 0x74, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x65,
    0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x32, 0x30, 0x20, 0x6d, 0x65,
    0x74, 0x65, 0x72, 0x20, 0x70, 0x61, 0x63, 0x65, 0x72, 0x20, 0x74, 0x65,
    0x73, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x67, 0x69,
    0x6e, 0x20, 0x69, 0x6e, 0x20, 0x33, 0x30, 0x20, 0x73, 0x65, 0x63, 0x6f,
    0x6e, 0x64, 0x73, 0x2e, 0x20, 0x4c, 0x69, 0x6e, 0x65, 0x20, 0x75, 0x70,
    0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x72,
    0x74, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69,
    0x6e, 0x67, 0x20, 0x73, 0x70, 0x65, 0x65, 0x64, 0x20, 0x73, 0x74, 0x61,
    0x72, 0x74, 0x73, 0x20, 0x73, 0x6c, 0x6f, 0x77, 0x6c, 0x79, 0x2c, 0x20,
    0x62, 0x75, 0x74, 0x20, 0x67, 0x65, 0x74, 0x73, 0x20, 0x66, 0x61, 0x73,
    0x74, 0x65, 0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x6d, 0x69, 0x6e,
    0x75, 0x74, 0x65, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x79, 0x6f,
    0x75, 0x20, 0x68, 0x65, 0x61, 0x72, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20,
    0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x2e};

JNIEXPORT void JNICALL
Java_net_minecraft_src_LabyrinthModNative_init(JNIEnv *env, jobject obj) {
  // If we've already done the process, don't do it again.
  if(hasInited) {
    return;
  }

  // Copy the hook value into our humble struct, while erasing out the old one so that the autosplitter doesn't catch it. 
  for (int i = 0; i < 283; i++) {
    GLOBAL_INFO.hook[i] = HOOK_VALUE[i];
    HOOK_VALUE[i] = 0;
  }

  GLOBAL_INFO.x = 0;
  GLOBAL_INFO.y = 0;
  GLOBAL_INFO.z = 0;
  hasInited = true;
}

JNIEXPORT void JNICALL Java_net_minecraft_src_LabyrinthModNative_setCoords(
    JNIEnv *env, jobject obj, jdouble x, jdouble y, jdouble z) {
  GLOBAL_INFO.x = x;
  GLOBAL_INFO.y = y;
  GLOBAL_INFO.z = z;
}




JNIEXPORT void JNICALL Java_net_minecraft_src_LabyrinthModNative_setShouldReset(
    JNIEnv *env, jobject obj, jboolean shouldReset) {
      GLOBAL_INFO.shouldReset = shouldReset;
    }

// obfuscated bindings

JNIEXPORT void JNICALL Java_om_init(JNIEnv *env, jobject obj) {
  Java_net_minecraft_src_LabyrinthModNative_init(env, obj);
}

JNIEXPORT void JNICALL Java_om_setCoords(JNIEnv *env, jobject obj, jdouble x,
                                         jdouble y, jdouble z) {
  Java_net_minecraft_src_LabyrinthModNative_setCoords(env, obj, x, y, z);
}

JNIEXPORT void JNICALL Java_om_setShouldReset(
    JNIEnv *env, jobject obj, jboolean shouldReset) {
      GLOBAL_INFO.shouldReset = shouldReset;
    }
